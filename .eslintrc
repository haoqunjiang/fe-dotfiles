# 本配置文件使用 YAML 格式编写
# 文件放在 ~ 目录下，省去了为每个项目复制一遍配置的琐碎操作
# 规则列表目前更新到 eslint v1.2.1
# 规则列表请参考：
# http://eslint.org/docs/rules/
# https://github.com/elijahmanor/eslint-plugin-smells
# https://github.com/yannickcr/eslint-plugin-react
#
# 命令行用户安装 Node.js + eslint + babel-eslint + eslint-plugin-smells + eslint-plugin-react 即可
# Sublime 用户还需安装 SublimeLinter + SublimeLinter-contrib-eslint 插件
# Atom 用户安装 linter + linter-eslint 插件，并且需要在每个项目的根目录下安装前述各个 npm package，并复制本文件
#
# 根据 ESLint 规则的格式，以下每一条规则的值均为数字或数组（数组的第一个元素为数字）
# 该数字表示警告等级，取值为 0、1 或 2，分别表示忽略、警告和禁止
#
# 目前这个文件是放在 ~/ 目录下的，供所有未配置 .eslintrc 的项目使用
# 因此为了保证最大的兼容性，此处设置了多个 env，开启了大量 ES6 特性，并关闭了和 ES5 不兼容的一些规则
#
# 如果需要将这个配置用到自己的项目中，请进行如下修改：
# 1. 根据自己的需要设置 env 和 ecmaFeatures 部分；
# 2. ES6 项目请开启本文件末尾的几条规则；
# 3. 非 React 项目请删掉 eslint-plugin-react，去除 jsx、react 相关规则，并在 globals 中去掉 React。



parser:
    babel-eslint    # 为了使用更多的新特性

# 环境设置
# 建议在每个文件中自行设置
env:
    browser: true
    node: true
    es6: true
    jquery: true
    commonjs: true
    amd: true

# 非 ES6 项目请全部关闭（直接删除即可，以下所有特性默认都是为 false）
ecmaFeatures:
    arrowFunctions: true
    binaryLiterals: true
    octalLiterals: true
    blockBindings: true
    classes: true
    defaultParams: true
    destructuring: true
    forOf: true
    modules: true
    objectLiteralComputedProperties: true
    objectLiteralShorthandMethods: true
    objectLiteralShorthandProperties: true
    restParams: true
    spread: true
    superInFunctions: true
    templateStrings: true

    generators: true    # 前端项目即使是 ES6 也不建议开启
    jsx: true   # 非 React 项目请关闭

    # 以下几个即使是 ES6 项目也请关闭
    objectLiteralDuplicateProperties: false
    regexUFlag: false
    regexYFlag: false
    unicodeCodePointEscapes: false

plugins:
    - smells
    - react

globals:
    # react 写法现在太多了……有的把 React 当成一个包 require/import，有的假设其为全局变量，此处暂且先当它是全局的
    React: true

rules:
    # Possible Errors & Best Practices

    # 禁止 trailing comma，因为在 IE8- 会报错
    comma-dangle: [2, never]

    # 如果使用了 console 中的方法则提示 warning，毕竟 console 一般用于调试输出，在线上环境不应出现
    # 而且加了 warning 后，在开发完成后，移除 console 语句时能更容易找到
    # 写 Node.js 代码时可以在文件开头的注释中关掉这个选项
    no-console: 1

    # 一般情况下不应该使用 debugger 语句进行调试（极端情况下还是有用的）
    no-debugger: 1

    # 除非是很小型的个人项目，不然一般不建议使用浏览器自带的 alert / prompt / confirm，毕竟太丑（调试时除外）
    no-alert: 1

    # return 语句中如果出现赋值，可能是想返回表达式的结果，也可能是想返回全等操作的比较结果然后手误漏输等号
    # 所以此处要求，除非额外加了括号，不然赋值操作不要在 return 语句中表达
    no-return-assign: [1, except-parens]

    # 禁止在条件表达式中进行赋值操作，除非有额外加上括号（比如 while((a = b)) 以及 while ((a = b) !== c) 都是被允许的）
    no-cond-assign: [2, except-parens]

    # 条件表达式不能为常数（比如 if (true) 这种）
    no-constant-condition: 1

    # 条件语句中没必要特地用双重否定 !! 将表达式转换为 boolean 类型
    no-extra-boolean-cast: 1

    # 提醒开发者不要把 !(a in b) 写成 !a in b
    no-negated-in-lhs: 2

    # 函数参数、对象定义时的属性、case 语句的标签名不允许重名
    no-dupe-args: 2
    no-dupe-keys: 2
    no-duplicate-case: 2

    # 空代码块应该警告
    no-empty: 1

    # catch 代码块中不允许对 error 对象覆盖赋值
    no-ex-assign: 2

    # 为了可读性，允许有不必要的括号
    no-extra-parens: 0

    # 多余的分号会警告
    no-extra-semi: 1

    # 避免忘了加分号而下一行以 ([ 等开头的情况
    no-unexpected-multiline: 2

    # 函数声明不得被覆盖赋值
    # 即，形如以下形式的代码被视为错误：
    # function foo() {}
    # foo = bar;
    # 函数表达式可以被覆盖赋值，即，以下代码不报错：
    # var foo = function() {};
    # foo = bar;
    no-func-assign: 2

    # ES6 引入了 block scoped function，这是一个 breaking change
    # 部分浏览器也已经在 strict mode 下实现了这个特性
    # 所以为了同时考虑 ES5 和 ES6 的兼容性，应当禁止在代码定义 block scoped function
    no-inner-declarations: [1, functions]

    # 禁止无效的正则表达式
    no-invalid-regexp: 2

    # 在正则中出现 0x0~0x31 的控制字符一般都是因为手误，根据官方建议，这里加上警告
    no-control-regex: 1

    # 正则表达式中不宜使用多个连续空格，最好使用形如 / {3}/ 这样的方式表示多个空格（此处仅用了一个空格字符）
    no-regex-spaces: 2

    # 零宽空格、行分隔符之类的非常规空白符要是不小心加进了代码，会引起难以察觉的错误，所以禁止（字符串中仍然可以使用）
    # 此外，JavaScript 规定字符串中不能（直接）出现 U+2028 和 U+2029 这两个字符，但 JSON 允许，这也是一个潜在的 bug 来源
    no-irregular-whitespace: 2

    # 正则中不允许出现空匹配组（/^abc[]/ 这种，这样的正则无法匹配任何字符串）
    no-empty-character-class: 2

    # 形如 /=foo/ 的正则应当写成 /\=foo/ 以免读者把 / 误看成除号（不过个人觉得这个规则没什么用）
    no-div-regex: 1

    # 全局变量 Math 和 JSON 没有 [[Call]] 属性，不能被当做函数调用
    no-obj-calls: 2

    # 直接定义稀疏数组字面量有很多潜在的风险，参见官方文档 http://eslint.org/docs/rules/no-sparse-arrays
    no-sparse-arrays: 2

    # 出现 unreachable code 说明代码有问题
    no-unreachable: 2

    # 不要试图直接拿变量和 NaN 比较（因为永远返回 false），用 isNaN 和 Number.isNaN
    use-isnan: 2

    # 唯一需要变量自己与自己比较的场景是判断 NaN，但是这种情况下优先使用 Number.isNaN
    # 不过 Number.isNaN 是 ES6 标准，IE 以及 Safari 8- 不支持，而 isNaN 又有类型转换
    # 所以在没有 polyfill 的情况下还是判断 x !== x 吧……
    no-self-compare: 1

    # 保证 JSDoc 注释符合其语法
    valid-jsdoc: 1

    # 跟 typeof 的结果对比的字符串必须是 number、string 等 typeof 表达式可能的取值，不然的话很有可能是出现了 typo
    valid-typeof: 2

    # 如果用 Object.defineProperty 定义了属性的 set 方法，则必须有配对的 get 方法
    accessor-pairs: [2, { getWithoutSet: true }]

    # 保证函数要么肯定会有返回值，要么肯定没有返回值，避免一些难以察觉的问题
    # 不过，更好的办法是直接用上 TypeScript/flow 写强类型的代码
    consistent-return: 1

    # if / else if / else / for / while / do 后面跟的代码块，必须加上花括号 {}
    curly: [1, all]

    # switch 语句不强制要求带 default
    default-case: 0

    # switch 语句如果出现了 fall-through 则警告
    no-fallthrough: 1

    # 尽可能用 dot-notation 而非下标来获取对象属性，避免可能的 bug
    # 为了保证与 ES3/IE8- 的兼容性，属性名为语法关键词的，仍然用字符串下标获取
    dot-notation: [2, { allowKeywords: true, allowPattern: '' }]

    # 相等性比较必须用 === 和 !==，除非是：两个字面量相比较 / 判断 typeof 结果 / 与 null 比较
    eqeqeq: [1, smart]

    # 允许与 null 比较，毕竟写 if (a == null) 比 if (a === null || a === undefined) 省事多了
    no-eq-null: 0

    # 在使用 for in 语句时必须做 hasOwnProperty 检查
    # 为了防止 hasOwnPeorperty 被覆盖，正确的用法是：{}.hasOwnProperty.call(obj, key)
    guard-for-in: 1

    # 考虑到与严格模式的兼容性，禁止使用 arguments.caller 和 arguments.callee
    no-caller: 1

    # 如果 if 语句中包含 return，则 else 中没必要加上 return，可以直接放到代码块后面
    # 具体的判断规则比较麻烦，可以参考文档 http://eslint.org/docs/rules/no-else-return
    no-else-return: 1

    # JavaScript 没有 goto 语句，label 只在循环和 switch 中有用，所以其他地方如果出现 label 那一定是出问题了
    no-empty-label: 2

    # 个人以为，一旦用到 label 的时候一定是很有必要的，毕竟 JS 没有了 goto 没有人会贪图方便而滥用 label 的
    no-labels: 0

    # 禁止使用 eval
    no-eval: 2

    # 禁止使用 execScript，禁止使用字符串作为 setTimeout、setInterval 的第一个参数
    no-implied-eval: 2

    # 一般情况下禁止使用 new Function
    # 当然如果写一些比较高级的库可能还是用得到的（比如 es6-module-loader 这种）
    no-new-func: 1

    # 给 location.href 赋值为 javascript: 开头的值的效果和 eval 相近，所以禁止
    # 给 a 标签的 href 赋值为 javascript:void(0) 时可以临时禁止（个人认为 javascript:void(0) 优于 #）
    no-script-url: 1

    # 禁止对原生对象进行覆盖赋值
    no-native-reassign: 2

    # 禁止扩展原生对象，如果是 polyfill，也建议直接引用 core-js 等第三方库而不是自己写
    no-extend-native: 2

    # 对于没有用到 this 的函数，没必要 bind
    no-extra-bind: 1

    # 浮点数不可省略小数点前的 0，形如 .5 -.7 的形式都会触发警告
    no-floating-decimal: 1

    # 不允许对 number/string 类型进行隐式强制类型转换（比如 +stringOfNumber 和 '' + foo 这样的形式）
    # 允许使用 !!foo 得到 boolean 值
    no-implicit-coercion: [1, { boolean: false, number: true, string: true }]

    # 上下文中不存在 this 的时候不能引用 this （注意：只有函数名以大写字母开头的才会被认为是 constructor 函数）
    # 因为 jQuery 的事件回调中存在大量的 this 引用，所以这里暂时选择关闭，非 jQuery 项目请打开
    # 详细文档 http://eslint.org/docs/rules/no-invalid-this
    no-invalid-this: 0

    # 在 ES5 前，一个 block 不会产生新的 scope，所以，纯粹的花括号是没有意义的
    # 如果用了 ES6，则请开启 blockBindings: true，此时这个规则失去作用
    no-lone-blocks: 1

    # 禁止使用 SpiderMonkey 的 __iterator__ 扩展
    # 关于 __iterator__ 可以看这两个文档：
    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Deprecated_and_obsolete_features#Object_methods
    # http://eslint.org/docs/rules/no-iterator
    no-iterator: 2

    # 循环中禁止定义函数
    # 不过有时候在循环里使用 forEach 之类的方法时，写 inline function 还是很方便的而且不会有什么问题
    # ESLint 无法对这种情况区别对待，所以只好降低提醒等级至「警告」
    no-loop-func: 1

    # 禁止通过 \ 后面跟换行符的方法定义多行字符串
    # 这个解析规则是 ES5 才有的（虽然 IE 6-8 只支持 ES3，但 JScript 已经额外实现了这个特性），也不够灵活（主要是对缩进的处理），建议使用字符串拼接
    # 而 ES6+ 则建议使用 template string 定义多行字符串
    no-multi-str: 1

    # 禁止 new Wrapper Objects
    # 即，禁止：new Object()、new Array()、new String()、new Number() 和 new Boolean()
    no-new-object: 2
    no-array-constructor: 2
    no-new-wrappers: 2

    # ES5+ 中，八进制的转义序列被 deprecated 了，应当用十六进制或 Unicode 来替代
    # 即，'\251' 应当改写为 '\u00A9' 或 '\xA9'
    no-octal-escape: 2

    # 禁止使用八进制字面量
    # ES5+ 在 sloppy mode 中 deprecate 了这个特性，而在 strict mode 中则完全禁止了
    no-octal: 2

    # 禁止对函数参数进行覆盖赋值（不过可以对参数的属性进行操作）
    no-param-reassign: [2, { props: false }]

    # 在 Node.js 中，尽量使用 config.js 文件而不是 process.env 来设置配置参数
    no-process-env: 1

    # 不建议使用 __proto__ 属性
    # 虽然很多浏览器（除了 IE10-）都实现了 __proto__，但是直到 ES6 才为了兼容性而被标准化
    # 但一般情况下仍然不建议使用 __proto__，推荐的方法是 Object.getPrototypeOf (IE 9+)
    no-proto: 1

    # 禁止重复声明变量以及全局变量
    # 针对场景：浏览器环境下会有很多全局变量，不注意的话很可能踩坑，比如以下代码
    # var top = 0; console.log(top + 1); // 在最外层作用域输出 'Object [Window]1'，其余情况输出 1
    # 这个规则应当与文件开头的 env 设置配合使用（因为不同环境下的 builtin globals 并不相同）
    no-redeclare: [2, { builtinGlobals: true }]

    # 禁止使用逗号语句
    # 除外情况：for 语句的初始化；被一对额外的括号包裹
    no-sequences: 1

    # throw 后面跟的只能是 new Error 对象，以便记录和查看调用栈
    no-throw-literal: 2

    # 尽量不要出现没有用到的表达式
    no-unused-expressions: 1

    # 去掉不必要的 .call 和 .apply，因为它们的效率会比直接调用函数差一点点
    no-useless-call: 1

    # ES5- 的 undefined 是可覆盖赋值的，而且子作用域里可以定义一个叫 undefined 的变量覆盖掉全局的 undefined
    # 所以此时需要用 void 0 获得真正的 undefined
    # 但一般情况下没必要用到 void，所以警告
    no-void: 1

    # 不要使用 with 语句
    no-with: 2

    # 调用 parseInt 方法需要提供 radix 参数
    radix: 1

    # 变量就近声明就好，全部提升到顶部不容易阅读
    vars-on-top: 0

    # IIFE 调用必须用括弧 () 包裹
    # 例：var x = (function () { return { y: 1 };})();
    wrap-iife: [2, inside]

    # 如果代码里有注释以 'TODO'、'FIXME' 字样开头的话，警告
    no-warning-comments: [1, { terms: ['todo', 'fixme'], location: 'start' }]

    # yoda conditions 即，条件判断语句中，常量前置
    # 个人认为这会影响可读性，而且 ESLint 已经保证了在条件判断中不会出现无意的赋值语句，所以禁用了这个规则
    yoda: 0



    # Strict Mode

    # 不强制使用严格模式（考虑到可能有第三方库不支持严格模式，所以不能用全局严格模式，而函数级的又太麻烦）
    # 当然，写代码的时候还是要考虑到严格模式下的兼容性
    strict: 0



    # Variables

    # 禁止使用未经声明的变量
    no-undef: 2

    # 只能把 var 定义的变量当做块级变量来用，避免因为 variable hoisting 带来的难以察觉的 bug，同时方便将来迁移到 ES6 的 let/const
    block-scoped-var: 1

    # 除函数以外，所有变量在使用前都应被定义
    no-use-before-define: [2, nofunc]

    # 个人觉得，在声明时是否初始化变量不是特别重要
    init-declarations: 0

    # IE8- 中，catch 语句的参数会覆盖上层作用域的同名变量，对于需要兼容低版本浏览器的项目需要注意
    no-catch-shadow: 2

    # 只有对象属性才能被 delete http://jslinterrors.com/only-properties-should-be-deleted/
    no-delete-var: 2

    # （为了可读性）标签名不应与变量名重名
    no-label-var: 2

    # 全局属性（NaN / Infinity / undefined）以及严格模式下的 restricted names （包括 eval / arguments）不可被覆盖
    no-shadow-restricted-names: 2

    # 禁止跟上层作用域中的变量重名
    no-shadow: [2, { builtinGlobals: false, hoist: 'functions' }]

    # 没必要把变量初始化为 undefined
    no-undef-init: 2

    # 考虑到 undefined 可能被覆盖，一般不建议直接使用它
    # foo === undefined 应该改用 typeof foo === 'undefined'
    no-undefined: 1

    # 定义过的变量都要被用到，不然的话很可能是没重构完导致的错误
    no-unused-vars: [1, { vars: 'all', args: 'after-used' }]



    # Node.js

    # if (err) { callback(err); } 应该写成 if (err) { return callback(err); }
    # 这个规则有一定的局限性，参见官方文档 http://eslint.org/docs/rules/callback-return
    callback-return: [2, ['callback', 'cb', 'next']]

    # 记得处理 err 参数
    handle-callback-err: 2

    # 这个解释起来有点麻烦，一般也用不到，可以参见官方文档 http://eslint.org/docs/rules/no-mixed-requires
    no-mixed-requires: 1

    # var foo = new require('foo'); 是把 require 当成构造器函数了，与 var foo = new (require('foo')); 不等价，容易误用
    # 更好的做法是 var Foo = require('foo'); var foo = new Foo();
    # 所以此处禁止直接在 require 语句里使用 new
    no-new-require: 2

    # 为了多平台兼容性，用 path.join 和 path.resolve 替代字符串拼接
    no-path-concat: 2

    # 一般不建议用 process.exit，更好的做法是抛出异常
    no-process-exit: 2

    # 禁止某些库的使用，一般情况下用不到
    # no-restricted-modules: [2, 'os', 'fs']

    # 不建议使用同步函数
    no-sync: 1



    # Stylistic Issues

    # 使用分号
    semi: [1, always]

    # 分号前不得有空格，分号后（如果有内容）必须有空格
    semi-spacing: [1, { before: false, after: true }]

    # 逗号只能出现在行中或行末，不能出现在行首
    comma-style: [1, last]

    # 逗号前不得有空格，逗号后（如果有内容）必须有空格
    comma-spacing: [1, { before: false, after: true }]

    # 如果在点号 . 处换行，点号应当在下一行行首
    dot-location: [1, property]

    # 如果在操作符（比如 +）处换行，操作符应当在下一行行首
    # 对于一长串字符串的拼接，感觉在行末更舒服
    operator-linebreak: 0 #[1, before]

    # 在变量定义后应当跟着一行空行
    # 目前尚有 bug 所以暂时关闭这个检查
    newline-after-var: 0 # [1, always]

    # 一律使用单引号，除非字符串的值中有单引号
    quotes: [1, single, avoid-escape]

    # 采用 4 个空格缩进，可以使代码看起来更整洁点
    indent: [1, 4]

    # 严禁空格和 Tab 混用
    no-mixed-spaces-and-tabs: 2

    # 禁止多个连续空格
    # 例外：对象属性、变量定义和 import 语句
    no-multi-spaces: [1, { exceptions: { Property: true, VariableDeclaration: true, ImportDeclaration: true } }]

    # 行末空格应当被去除
    no-trailing-spaces: 1

    # 调用函数时，函数名和括号间不能有空格
    no-spaced-func: 1

    # 中缀操作符两侧都需要有空格（a|0 这种强制转换 a 为 int32 类型的操作除外）
    space-infix-ops: [1, { int32Hint: false }]

    # 单词形式的单目操作符（new、delete、void、typeof 等）后面应当跟有空格
    # 符号形式的单目操作符（++、--、-、+、!、!! 等）后面不应有空格
    space-unary-ops: [1, { words: true, nonwords: false }]

    # 关键词 if / else / for / while / do / switch / try / catch / finally / with 之后需要跟空格
    # 比如 if (cond) 不能写成 if(cond)
    space-after-keywords: [1, always]

    # 对上一个规则的补充，针对 return / throw / case
    space-return-throw-case: 1

    # 函数定义的 () 前不应有空格
    # 示例：function() {}、function foo() {}
    space-before-function-paren: [1, never]

    # 代码块的花括号 { 前面应当有个空格
    space-before-blocks: [1, always]

    # 花括号 { 一律在行末，除非表达式只有一行
    brace-style: [1, 1tbs, { allowSingleLine: true }]

    # ( 右侧和 ) 左侧不应有空格
    space-in-parens: [1, never]

    # object literal 的 { 后以及 } 前都应有空格
    object-curly-spacing: [1, always]

    # 对于数组的话，个人觉得不带空格更美观
    array-bracket-spacing: [1, never]

    # computed property 的方括号中是否需要带空格无所谓，属性名太复杂时加空格保证可读性，简单的话就不加了
    computed-property-spacing: 0

    # 定义对象属性时，冒号前不应有空格，冒号后必须有空格；在需要对齐的场合，padding 空格加在冒号右侧，但不强制要求对齐
    key-spacing: [1, { beforeColon: false, afterColon: true }]

    # 用于注释的 // 和 /* 后面应当有个空格
    spaced-comment: [1, always]

    # 在多行注释开始前要有一个空行（在代码块开头的时候除外）
    lines-around-comment: [1, { beforeBlockComment: true, allowBlockStart: true }]

    # 代码块首尾不应有空行
    padded-blocks: [1, never]

    # 最多可以有连续 5 个空行
    no-multiple-empty-lines: [1, { max: 5 }]

    # 必须用 LF 作为换行符
    linebreak-style: [2, unix]

    # 非空文件应当以换行结尾（UNIX 惯例）
    eol-last: 1

    # else 语句中如果有且仅有一个 if 判断
    # 即，形如 else { if () {} } 的语句，应当用 else if 代替
    no-lonely-if: 1

    # 定义 object literal 时，属性名如非必要，不应加引号，不过需要优先保证一致性（即，如果有一个属性名必须加引号，则其它属性名也要加）
    quote-props: [1, consistent-as-needed]

    # 以下划线开头的变量命名个人感觉并无不妥
    no-underscore-dangle: 0

    # 采用驼峰命名法（不检查对象属性的命名，考虑到可能会和后端数据通信等情况）
    camelcase: [1, { properties: never }]

    # 如果要把 this 赋给一个临时的变量，那这个变量必须命名为 self，而不是 that 或者其他什么
    # ES6+ 的项目请使用箭头函数，不需要这个规则，参见 smells/no-this-assign 规则
    consistent-this: [1, 'self']

    # 不要求每个函数都有 function name，函数表达式里还是允许匿名函数的，不过给函数表达式加上函数名有利于输出更清晰的 stack trace
    func-names: 0

    # 使用函数表达式还是函数声明来定义函数，随开发者喜好而定，不作要求
    func-style: 0

    # 对标示符长度不作限制，考虑到有些人写过 Objective-C，习惯长变量名……
    id-length: 0

    # 构造器函数必须以大写字母开头、以大写字母开头的函数只能作为构造器函数被调用（除了内置类型比如 Array 这些）
    new-cap: [1, { newIsCap: true, capIsNew: true }]

    # 虽然 JavaScript 允许在 new 的时候函数名后面不带括号，不过这个风格看起来不大舒服，所以还是要求必须加上括号
    new-parens: 1

    # 允许使用 continue 语句
    no-continue: 0

    # 允许行内注释
    no-inline-comments: 0

    # 允许使用三目运算符
    no-ternary: 0

    # 但不要嵌套三目运算，这样可读性很差
    no-nested-ternary: 1

    # 没必要的三目运算也应该去掉，比如 var a = (x === 2) ? true : false;
    no-unneeded-ternary: 1

    # 有的规范建议正则表达式用括号括起来，以增加可读性
    # 不过个人认为没必要
    wrap-regex: 0

    # 变量声明主要考虑可读性，不必强制在一个 var 语句或者多个语句中声明
    one-var: 0

    # 变量声明的顺序由作者自行考虑，不强制
    sort-vars: 0

    # operator assignment shorthand 如 += 等，在可读性好的时候再用，不强制统一风格
    operator-assignment: 0

    # 这个规则用于置顶代码中标示符的命名规范
    # 个人觉得有点不必要……而且真正想要规范的部分是无法简单地用正则表达出来的（比如 button 必须缩写为 btn 之类的规范）
    id-match: 0



    # Complexity

    # 单个函数最多有 16 行（内部的其他函数定义不算）
    max-statements: [2, 16]

    # 至多嵌套五层代码块
    max-depth: [2, 5]

    # 每行最多 140 个字符，比 80 个字符多一点，毕竟可能会有很多缩进，而且反正显示器够大
    max-len: [1, 140]

    # 上限设置到 10 是因为 Angular 依赖注入可能会有很多
    max-params: [1, 10]

    # 最多允许嵌套两层回调
    max-nested-callbacks: [2, 2]

    # [cyclomatic complexity](http://en.wikipedia.org/wiki/Cyclomatic_complexity) 圈复杂度上限为 7
    complexity: [2, 7]



    # ES6

    # 箭头函数的参数，仅在有必要时才加上括号
    arrow-parens: [1, as-needed]

    # => 前后都应有空格
    arrow-spacing: [1, { before: true, after: true }]

    # 派生类的构造器函数必须有 super() 调用，其他情况下构造器函数都不允许调用 super()
    constructor-super: 2

    # 派生类必须先调用过 super() 才能引用 this
    no-this-before-super: 2

    # 生成器函数的星号前需要有空格，星号后不能有空格，例如 function *foo() {}
    generator-star-spacing: [1, { before: true, after: false }]

    # 不要写出不带 yield 语句的生成器函数
    require-yield: 1

    # 不要出现以下例子里的情况：
    # class A {}
    # A = 0;
    no-class-assign: 2

    # 不能对常量进行赋值
    no-const-assign: 2

    # 禁止 class 定义中出现两个同名成员
    no-dupe-class-members: 2

    # 是否使用 object shorthand 应该由开发者视可读性而定，不一刀切
    object-shorthand: 0

    # 如果需要使用的方法可以用 Reflect 的接口完成，则优先使用 Reflect
    # 不过由于 Reflect 不可被 polyfill 而且也没有完整实现，暂不开启
    prefer-reflect: 0



    # 更严格的控制代码复杂度的规则 http://elijahmanor.github.io/talks/js-smells/

    # 允许使用 switch 语句
    smells/no-switch: 0

    # 但禁止 case 条件后面跟着超过一行语句（大部分情况下这种情况都能被重构成其他更易读的写法）
    smells/no-complex-switch-case: 1

    # 禁止 setInterval（对时间要求精确的动画除外）（为了防止 timer 未清除之类的乱七八糟的错误）
    # 感觉这个规则不大靠谱，出发点是好的但是不应该这样实现
    # smells/no-setinterval: 1


    # 禁止连续反复操作同一个变量，用 forEach、reduce、_.flow 都可以解决
    # 尚未支持
    # smells/no-reassign: 1


    # React 相关

    # 现在 React 开发都直接用 ES6 class syntax 了，不需要手动设置 displayName
    react/display-name: 0

    # Enforce boolean attributes notation in JSX
    react/jsx-boolean-value: 1

    # Disallow undeclared variables in JSX
    react/jsx-no-undef: 1

    # 在 JSX 中一律使用单引号
    react/jsx-quotes: [1, single, avoid-escape]

    # Enforce propTypes declarations alphabetical sorting
    react/jsx-sort-prop-types: 1

    # Enforce props alphabetical sorting
    react/jsx-sort-props: 1

    # Prevent React to be incorrectly marked as unused
    react/jsx-uses-react: 1

    # Prevent variables used in JSX to be incorrectly marked as unused
    react/jsx-uses-vars: 1

    # Prevent usage of setState in componentDidMount
    react/no-did-mount-set-state: 1

    # Prevent usage of setState in componentDidUpdate
    react/no-did-update-set-state: 1

    # Prevent multiple component definition per file
    react/no-multi-comp: 1

    # Prevent usage of unknown DOM property
    react/no-unknown-property: 1

    # Prevent missing props validation in a React component definition
    react/prop-types: 1

    # Prevent missing React when using JSX
    react/react-in-jsx-scope: 1

    # Prevent extra closing tags for components without children
    react/self-closing-comp: 1

    # 组件的方法定义要按一定的顺序规则
    # 默认配置见此 -> https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/sort-comp.md
    react/sort-comp: 1

    # Prevent missing parentheses around multilines JSX
    react/wrap-multilines: 1



    # ES6 项目请开启以下几个规则（将 0 改为 1）

    # 仅使用 let 和 const，不使用 var
    no-var: 0

    # 对于不会被修改的变量，优先考虑使用 const 而非 let
    prefer-const: 0

    # 如果仅仅是为了使用数组作为函数参数，那么应该优先考虑使用 spread operator 而不是 .apply()
    prefer-spread: 0

    # 回调函数尽可能使用箭头函数
    prefer-arrow-callback: 0

    # 禁止复杂的字符串拼接，用模板引擎或 ES6 template string 替代
    prefer-template: 0

    # 不要写 var self = this; 尽量使用 bind 和 箭头函数
    smells/no-this-assign: 0

    # 这个与 prefer-template 重复了
    smells/no-complex-string-concat: 0
